# 贪吃蛇之智能蛇实验报告  

![智能蛇](images/20171226165223772.gif)  

## 一、实验目的
### 1.了解 算法 与 “智能” 的关系
### 2.通过算法赋予蛇智能
### 3.了解 Linux IO 设计的控制
## 二、实验环境
### 1.Linux Only. 你可以选择 Unbutu、Centos 等发行版。
### 2.建议编辑环境 Vim 或 Vscode, 编译 gcc
### 3.第一次使用 Linux，建议使用虚拟机。可以使用其他同学准备好的 Vbox 镜像  
## 三、控制输入/输出设备
你知道为什么一行代码要控制在80（字符）列以内？ 原因是 … 原来历史上读程序的卡片机只能读80个字符。当然，超过 80 个字符也打不出来阅读了。
那么一个语句超过 80 个字符怎么办？ 续行符…
言归正传，早期的输出设备显示器、打印机，输入设备键盘（打字机）都是80列行缓冲顺序输入和输出设备。即你打印文件时，打印机必须等收到行结束符，打印机才会动作。然而，输入/输出随着应用需求不断进化，字符界面控制与管理已经非常标准化了。
### 1、VT 100 终端标准


### 2、实现 kbhit()
检测 tty 输入的程序，远远超出了入门者的能力，你只需要会运行该程序，并将 snake 代码融入该代码。  
## 四、编写智能算法
编写人工智能程序，使得 snake 每秒自动走一步。
### 1、程序要求
请修改初始化字符矩阵，或者通过文件读入地图。地图中有一些你设定的障碍物（墙）
请实现如下算法决定蛇行走的方向
思考：一个长度为5的障碍物能困死该自动跑的蛇吗？  
### 决定蛇行走的方向函数的伪代码
    // Hx,Hy: 头的位置
    // Fx,Fy：食物的位置
	function whereGoNext(Hx,Hy,Fx,Fy) {
	// 用数组movable[3]={“a”,”d”,”w”,”s”} 记录可走的方向
	// 用数组distance[3]={0,0,0,0} 记录离食物的距离
	// 分别计算蛇头周边四个位置到食物的距离。H头的位置，F食物位置
	//     例如：假设输入”a” 则distance[0] = |Fx – (Hx-1)| + |Fy – Hy|
	//           如果 Hx-1，Hy 位置不是Blank，则 distance[0] = 9999
	// 选择distance中存最小距离的下标p，注意最小距离不能是9999
	// 返回 movable[p]
	}
### 2、智能蛇的程序框架
	输出字符矩阵
	WHILE not 游戏结束 DO
        wait(time)
		ch＝whereGoNext(Hx,Hy,Fx,Fy)
		CASE ch DO
		‘A’:左前进一步，break 
		‘D’:右前进一步，break    
		‘W’:上前进一步，break    
		‘S’:下前进一步，break    
		END CASE
		输出字符矩阵
	END WHILE
	输出 Game Over!!! 
### 3、函数设计   


## 五、总结  
     首先将贪吃蛇赋予智能， 最困难的地方在于不要只为了眼前的利益——直接快速的吃到食物而葬送自己的生命， 所以简简单单的让蛇头向着食物的方向走这样的贪吃蛇是活不了多长的。

    首先介绍一种脑残算法：就是让蛇头紧挨着蛇身一列一列的扫屏。 这样蛇头早晚会走过放置食物的随机位置， 吃到食物。 不会误打误撞而白白丧命。 但是这种算法耗时长效率低， 而且对于出现一段时间后消失的食物有可能出现总也吃不到食物的情况（想象食物跟着蛇尾走）。

    接着介绍一下观察上图的智能贪吃蛇的一些算法剖析和心得。

        首先， 蛇头总是挨着蛇身走， 这样不仅使整个画面清晰， 而且为贪吃蛇节约可以行走的空间， 减少被自己的身子围起来而无法行走的空间。
        其次，当蛇往当前移动方向的相反方向去吃食物时会在图像的边缘预留一行或一列给自己逃生，防止因逃出画面或者将自己困在两侧的身子中而牺牲。
        然后，尽量为大块的空间流出至少两行或两列的进出口， 使得贪吃蛇可以进入其中吃东西或者放自己多余的身子。
        当贪吃蛇为了吃到食物而没有贴着身子走的时候， 吃到食物后立即贴着身子走或者掉头。
